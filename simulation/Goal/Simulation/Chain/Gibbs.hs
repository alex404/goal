{-# LANGUAGE FlexibleContexts,Arrows #-}

-- | Gibbs sampling/contrastive divergence for exponential Family 'Harmonium's.
module Goal.Simulation.Chain.Gibbs where


--- Imports ---


-- Goal --

import Goal.Core
import Goal.Geometry
import Goal.Probability

import qualified Goal.Core.Vector.Boxed as B
import qualified Goal.Core.Vector.Generic as G

import Goal.Simulation.Circuit
import Goal.Simulation.Chain

--- Types ---

{-
-- | Returns a Markov chain over the latent and observable states generated by Gibbs sampling.
gibbsChain
    :: (ExponentialFamily l, Generative Natural l, ExponentialFamily o, Generative Natural o, RealFloat x)
    => Point Natural (Harmonium l o) x -- ^ The harmonium
    -> Sample o -- ^ The initial states of the Gibbs chains
    -> Random s (Chain (Sample l, Sample o)) -- ^ The resulting Gibbs chains
gibbsChain p z0 = do
    chn <- bulkGibbsChain p $ singleton z0
    return $ chn >>> arr headV
    -}


{-
-- | Returns a Markov chain over the sufficient statistics of the latent and
-- observable states generated by Gibbs sampling.
gibbsChain'
    :: (ExponentialFamily x, StandardGenerative Natural x, ExponentialFamily z, StandardGenerative Natural z)
    => (Natural :#: Harmonium x z) -- ^ The harmonium
    -> Mixture :#: z -- ^ The initial sufficient statistics of the Gibbs chains
    -> RandST s (Chain (Mixture :#: x, Mixture :#: z)) -- ^ The resulting Gibbs chains
gibbsChain' p mz0 = do
    chn <- bulkGibbsChain' p [mz0]
    return $ chn >>> arr head
-}

-- | Returns a Markov chain over the xatent and observable states generated by Gibbs sampling.
bulkGibbsChain
    :: ( Bilinear Mean Natural f, KnownNat k
       , ExponentialFamily (Codomain f), Generative Natural (Codomain f)
       , ExponentialFamily (Domain f), Generative Natural (Domain f) )
     => Point Natural (Harmonium f) -- ^ The harmonium
    -> B.Vector k (Sample (Domain f)) -- ^ The initial states of the Gibbs chains
    -> Random s (Chain (B.Vector k (Sample (Harmonium f)))) -- ^ The resulting Gibbs chains
{-# INLINE bulkGibbsChain #-}
bulkGibbsChain hrm z0s = do
    x0s <- mapM sample . G.convert $ conditionalLatentDistributions hrm z0s
    zstp <- accumulateRandomFunction0 (B.mapM sample . G.convert . conditionalObservableDistributions hrm)
    xstp <- accumulateRandomFunction0 (B.mapM sample . G.convert . conditionalLatentDistributions hrm)
    return . accumulateCircuit (x0s,z0s) $ proc ((),(xs,zs)) -> do
        zs' <- zstp -< xs
        xs' <- xstp -< zs'
        returnA -< (B.zip xs zs,(xs',zs'))

{-
-- | Returns a Markov chain over the sufficient statistics of the latent and
-- observable states generated by Gibbs sampling.
bulkGibbsChain'
    :: (ExponentialFamily x, StandardGenerative Natural x, ExponentialFamily z, StandardGenerative Natural z)
    => (Natural :#: Harmonium x z) -- ^ The harmonium
    -> [Mixture :#: z] -- ^ The initial sufficient statistics of the Gibbs chains
    -> RandST s (Chain [(Mixture :#: x, Mixture :#: z)]) -- ^ The resulting Gibbs chains
bulkGibbsChain' p mz0s = do
    let cxaff = conditionalLatentDistribution p
        czaff = conditionalObservableDistribution p
    x0s <- mapM standardGenerate $ cxaff >$> mz0s
    let (Harmonium x z) = manifold p
        mx0s = sufficientStatistic x <$> x0s
    zstp <- accumulateRandomFunction0 (\mxs -> mapM standardGenerate $ czaff >$> mxs)
    xstp <- accumulateRandomFunction0 (\mzs -> mapM standardGenerate $ cxaff >$> mzs)
    return . accumulateCircuit (mx0s,mz0s) $ proc ((),(mxs,mzs)) -> do
        zs' <- zstp -< mxs
        let mzs' = sufficientStatistic z <$> zs'
        xs' <- xstp -< mzs'
        let mxs' = sufficientStatistic x <$> xs'
        returnA -< (zip mxs mzs,(mxs',mzs'))

dualContrastiveDivergence
    :: ( ExponentialFamily x, StandardGenerative Natural x
       , ExponentialFamily y, StandardGenerative Natural y
       , ExponentialFamily z, StandardGenerative Natural z )
    => Int -- ^ Number of Contrastive divergence steps
    -> [Sample z] -- ^ The observations
    -> Natural :#: x
    -> Natural :#: y
    -> Natural :#: DeepHarmonium x y z -- ^ The harmonium
    -> RandST s (Differentials :#: Tangent Natural (DeepHarmonium x y z)) -- ^ The resulting stochastic gradient
dualContrastiveDivergence dcdn zs' rx ry dhrm = do
    let (DeepHarmonium xm ym zm) = manifold dhrm
        mzs' = sufficientStatistic zm <$> zs'
    xyzs <- sampleStronglyRectifiedDeepHarmonium (length zs') rx ry dhrm
    let hrms' = conditionalLatentHarmonium dhrm mzs'
        (xs,ys,zs) = unzip3 xyzs
    chns <- sequence $ [gibbsChain hrm' y | (hrm',y) <- zip hrms' ys]
    let (xs',ys') = unzip $ (!! dcdn) . streamChain <$> chns
        mxs = sufficientStatistic xm <$> xs
        mxs' = sufficientStatistic xm <$> xs'
        mys = sufficientStatistic ym <$> ys
        mys' = sufficientStatistic ym <$> ys'
        mzs = sufficientStatistic zm <$> zs
    return $ deepHarmoniumGradientCalculator mxs mxs' mys mys' mzs mzs' dhrm

strongRectificationDifferentials
    :: ( ClosedFormExponentialFamily x, StandardGenerative Natural x
       , ClosedFormExponentialFamily y, StandardGenerative Natural y
       , ClosedFormExponentialFamily z, StandardGenerative Natural z )
    => Int
    -> Int
    -> Natural :#: x
    -> Natural :#: y
    -> Natural :#: DeepHarmonium x y z
    -> RandST s (Differentials :#: Tangent Natural (DeepHarmonium x y z))
strongRectificationDifferentials cdn n rx ry dhrm = do
    let (DeepHarmonium xm ym zm) = manifold dhrm
        (nx,ny,nz,nxy,nxz) = splitDeepHarmonium dhrm
        hrm1 = joinHarmonium ny nz nxz
        hrm2 = joinHarmonium nx ry nxy
    dhrm1 <- rectificationDifferentials cdn n ry hrm1
    dhrm2 <- rectificationDifferentials cdn n rx hrm2
    let csdx = C.replicate (dimension xm) 0
        (csdy,csdxy) = C.splitAt (dimension ym) . C.drop (dimension xm) $ coordinates dhrm2
        (csdz,csdyz) = C.splitAt (dimension zm) . C.drop (dimension ym) $ coordinates dhrm1
    return . fromCoordinates (Tangent dhrm) $ csdx C.++ csdy C.++ csdz C.++ csdxy C.++ csdyz

bulkContrastiveDivergence
    :: (ExponentialFamily x, StandardGenerative Natural x, ExponentialFamily z, StandardGenerative Natural z)
    => Int -- ^ Number of Contrastive divergence steps
    -> [Sample z] -- ^ The observations
    -> (Natural :#: Harmonium x z) -- ^ The harmonium
    -> RandST s (Differentials :#: Tangent Natural (Harmonium x z)) -- ^ The resulting stochastic gradient
bulkContrastiveDivergence cdn zs' hrm = do
    chn <- bulkGibbsChain hrm zs'
    let Harmonium x z = manifold hrm
        chnstps = streamChain chn
        (xs',_) = unzip $ head chnstps
        (xs,zs) = unzip $ chnstps !! cdn
        mxs = sufficientStatistic x <$> xs
        mxs' = sufficientStatistic x <$> xs'
        mzs = sufficientStatistic z <$> zs
        mzs' = sufficientStatistic z <$> zs'
    return $ harmoniumGradientCalculator mxs mxs' mzs mzs' hrm

bulkContrastiveDivergence'
    :: (ExponentialFamily x, StandardGenerative Natural x, ExponentialFamily z, StandardGenerative Natural z)
    => Int -- ^ Number of Contrastive divergence steps
    -> [Mixture :#: z] -- ^ The observations
    -> (Natural :#: Harmonium x z) -- ^ The harmonium
    -> RandST s (Differentials :#: Tangent Natural (Harmonium x z)) -- ^ The resulting stochastic gradient
bulkContrastiveDivergence' cdn mzs' hrm = do
    chn <- bulkGibbsChain' hrm mzs'
    let chnstps = streamChain chn
        (mxs',_) = unzip $ head chnstps
        (mxs,mzs) = unzip $ chnstps !! cdn
    return $ harmoniumGradientCalculator mxs mxs' mzs mzs' hrm


rectificationDifferentials
    :: (ClosedFormExponentialFamily x, ClosedFormExponentialFamily z, StandardGenerative Natural x, StandardGenerative Natural z)
    => Int
    -> Int
    -> Natural :#: x
    -> Natural :#: Harmonium x z
    -> RandST s (Differentials :#: Tangent Natural (Harmonium x z))
rectificationDifferentials cdn n rx hrm = do
    xs' <- replicateM n $ standardGenerate rx
    chn <- bulkGibbsChain (harmoniumTranspose hrm) xs'
    let Harmonium x z = manifold hrm
        chnstps = streamChain chn
        (zs',_) = unzip $ head chnstps
        (zs,xs) = unzip $ chnstps !! cdn
        mxs = sufficientStatistic x <$> xs
        mxs' = sufficientStatistic x <$> xs'
        mzs = sufficientStatistic z <$> zs
        mzs' = sufficientStatistic z <$> zs'
        dhrm = harmoniumGradientCalculator mxs mxs' mzs mzs' hrm
    return . fromCoordinates (manifold dhrm) $ C.replicate (dimension x) 0 C.++ C.drop (dimension x) (coordinates dhrm)

{-
rectificationDifferentials
    :: (ClosedFormExponentialFamily x, ClosedFormExponentialFamily z, StandardGenerative Natural x, StandardGenerative Natural z)
    => Int
    -> Int
    -> Natural :#: x
    -> Natural :#: Harmonium x z
    -> RandST s (Differentials :#: Tangent Natural (Harmonium x z))
rectificationDifferentials cdn n rx hrm = do
    xs <- replicateM n $ standardGenerate rx
    dhrmt <- bulkContrastiveDivergence cdn xs $ harmoniumTranspose hrm
    let dhrm = Natural # fromCoordinates (manifold hrm) (coordinates dhrmt)
    return . fromCoordinates (Tangent hrm) . coordinates $ harmoniumTranspose dhrm
    -}
    -}
