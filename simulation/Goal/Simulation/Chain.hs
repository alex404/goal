{-# LANGUAGE RankNTypes #-}

-- | Tools for working with discrete time stochastic processes.

module Goal.Simulation.Chain
    ( -- * Chains
      Chain
    , chain
    , generator
    , streamChain
    , accelerateChain
    , accumulateRandomChain
    ) where

--- Imports ---


-- Goal --

import Goal.Core
import Goal.Probability

import Goal.Simulation.Circuit


--- Stochastic Processes ---


-- | A 'Chain' is a realization of a stochastic process.
type Chain x = Circuit () x

-- | Creates a 'Chain' from an initial state and a transition function. The
-- first step of the chain returns the initial state, and then continues with
-- generated states.
chain :: x -- ^ The initial state
      -> (x -> forall s . Random s x) -- ^ The transition function
      -> Random s' (Chain x) -- ^ The resulting 'Chain'
{-# INLINE chain #-}
chain x0 gntr = accumulateRandomFunction x0 $ \() x -> do
    x' <- gntr x
    return (x,x')

-- | Converts a list into a 'Chain'. The input list should probably be infinite,
-- or the 'Chain' will eventually throw an error.
generator :: [x] -> Chain x
generator xs = accumulateFunction xs (\() (x:xs') -> (x,xs'))

-- | A convenience function for streaming 'Chain's.
streamChain :: Chain x -> [x]
{-# INLINE streamChain #-}
streamChain = stream (repeat ())

accelerateChain :: Int -> Chain x -> Chain x
-- | Streams a chain but skips every n steps.
{-# INLINE accelerateChain #-}
accelerateChain n (Circuit f) = Circuit $ \a ->
    let (b,crc') = f a
     in (b,accelerateChain n . fst $ mapAccumL runCircuit' crc' (replicate n ()))
    where runCircuit' (Circuit g) a = let (b,g') = g a in (g',b)

-- | Repeatedly samples from the given random variable.
accumulateRandomChain :: (forall s . Random s a) -> Random s' (Chain a)
{-# INLINE accumulateRandomChain #-}
accumulateRandomChain rf = accumulateRandomFunction0 (const rf)


{-
-- | A convenience function for streaming 'Chain's with an additional monadic operation.
streamChainM :: Monad m => Chain x -> (x -> m y) -> m [y]
streamChainM = streamM (repeat ())

-- | A convenience function for streaming 'Chain's with an additional monadic
-- operation where we don't care about the results.
streamChainM_ :: Monad m => Chain x -> (x -> m y) -> m ()
streamChainM_ = streamM_ (repeat ())

-- Markov --

-- | The space of stochastic matrices for describing discrete space Markov
-- chains.
type MarkovTensor s = Tensor (CurvedCategorical s) (CurvedCategorical s)

-- | A simple function for creating a 'MarkovTensor'.
markovTensor :: s -> MarkovTensor s
markovTensor s = Tensor (CurvedCategorical s) (CurvedCategorical s)

-- | Constructs the transition function for a Markov 'Chain' based on a given
-- stochastic matrix.
markovTransition :: Discrete s
    => (Function Standard Standard :#: MarkovTensor s) -- ^ The stochastic matrix
    -> Element s -- ^ The current state
    -> Random r (Element s) -- ^ The Markov chain step
markovTransition smtx k = do
    let ks = elements . sampleSpace . domain $ manifold smtx
        sk = fromList (domain $ manifold smtx) [ if k' == k then 1 else 0 | k' <- ks ]
    generate $ smtx >.> sk


--- Utility ---


-- | Flattens a 'Chain' over lists into a 'Chain' over the elements of the
-- lists. The lists generated by the input 'Chain' must, however, not be empty.
flattenChain :: Chain [x] -> Chain x
flattenChain mly = accumulateCircuit [] $ proc ((),xs) ->
    if null xs
       then do
           (xnew:xsnew') <- mly -< ()
           returnA -< (xnew,xsnew')
       else returnA -< (head xs, tail xs)

-}
